name: Build Hytale Server Image

on:
  push:
    branches: [master, bug/refresh-token-fix-again]
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      force_build:
        description: Force a rebuild even if upstream version is unchanged
        type: boolean
        default: false

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Hytale downloader tool
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL https://downloader.hytale.com/hytale-downloader.zip -o hytale-downloader.zip
          unzip -q hytale-downloader.zip
          chmod +x hytale-downloader-linux-amd64

      - name: Write downloader credentials (current directory)
        shell: bash
        env:
          HYTALE_REFRESH_TOKEN: ${{ secrets.HYTALE_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          if [[ -z "${HYTALE_REFRESH_TOKEN:-}" ]]; then
            echo "::error::Missing HYTALE_REFRESH_TOKEN"
            exit 1
          fi

          if [[ "${HYTALE_REFRESH_TOKEN}" != ory_rt_* ]]; then
            echo "::error::HYTALE_REFRESH_TOKEN does not look like a refresh token"
            exit 1
          fi

          # Write to CURRENT DIRECTORY, not HOME
          # This is where the downloader actually looks for credentials
          printf '%s\n' \
            "{\"access_token\":\"\",\"refresh_token\":\"${HYTALE_REFRESH_TOKEN}\",\"expires_at\":0,\"branch\":\"release\"}" \
            > .hytale-downloader-credentials.json

          chmod 600 .hytale-downloader-credentials.json

          echo "Credentials written to $(pwd)/.hytale-downloader-credentials.json"
          echo "Working directory: $(pwd)"

      - name: Debug - Check credentials before downloader
        shell: bash
        run: |
          set -euo pipefail
          echo "=== DEBUG: Credentials file check BEFORE downloader ==="
          echo "PWD=${PWD}"
          
          cred=".hytale-downloader-credentials.json"
          if [[ -f "$cred" ]]; then
            echo "✓ Credentials file exists at: $(pwd)/$cred"
            echo "File size: $(stat -c%s "$cred" 2>/dev/null || stat -f%z "$cred" 2>/dev/null || echo 'unknown') bytes"
            echo "Refresh token starts with: $(jq -r '.refresh_token // ""' "$cred" | cut -c1-20)..."
          else
            echo "✗ Credentials file NOT found at: $(pwd)/$cred"
          fi

      - name: Get upstream version
        id: upstream
        shell: bash
        run: |
          set -euo pipefail

          echo "Running downloader to get version..."
          echo "Working directory: $(pwd)"
          
          # Downloader looks in current directory, not HOME
          set +e
          timeout 90s stdbuf -oL -eL \
            ./hytale-downloader-linux-amd64 -print-version \
            2>&1 | tee downloader-version.log
          rc=${PIPESTATUS[0]}
          set -e

          # Save return code for later steps
          echo "${rc}" > /tmp/downloader_rc

          echo "=== DEBUG: Full downloader output ==="
          cat downloader-version.log
          echo "=== END downloader output ==="

          if [[ $rc -eq 124 ]]; then
            echo "::error::Downloader timed out (would indicate device auth fallback)"
            exit 124
          fi
          if [[ $rc -ne 0 ]]; then
            echo "::error::Downloader failed with exit code: $rc"
            exit $rc
          fi

          version="$(tail -n 1 downloader-version.log | tr -d '\r\n ')"
          if [[ -z "$version" ]]; then
            echo "::error::Version empty"
            cat downloader-version.log
            exit 1
          fi

          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "Captured version: ${version}"

      - name: Debug - Check credentials after downloader
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "=== DEBUG: Credentials file check AFTER downloader ==="
          
          cred=".hytale-downloader-credentials.json"
          if [[ -f "$cred" ]]; then
            echo "✓ Credentials file exists at: $(pwd)/$cred"
            echo "File size: $(stat -c%s "$cred" 2>/dev/null || stat -f%z "$cred" 2>/dev/null || echo 'unknown') bytes"
            echo "File contents (redacted):"
            jq '{access_token: (.access_token | if . == "" then "EMPTY" else "SET" end), refresh_token: (.refresh_token | if . == "" then "EMPTY" elif . then (.[:20] + "...") else "NULL" end), expires_at, branch}' "$cred" || cat "$cred"
          else
            echo "✗ Credentials file NOT found at: $(pwd)/$cred"
          fi

      - name: Persist rotated refresh token
        # CRITICAL: Run this even if previous step failed, as long as credentials file exists
        # The token may have already been rotated even if the downloader failed
        if: always()
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_SECRETS_TOKEN }}
        run: |
          set -euo pipefail

          cred=".hytale-downloader-credentials.json"
          if [[ ! -f "$cred" ]]; then
            echo "::warning::No credentials file to persist"
            exit 0
          fi

          new_rt="$(jq -r '.refresh_token // ""' "$cred")"
          if [[ -z "$new_rt" ]]; then
            echo "::warning::Empty refresh token in credentials file"
            exit 0
          fi
          
          if [[ "$new_rt" != ory_rt_* ]]; then
            echo "::warning::Refresh token does not match expected format (ory_rt_*)"
            exit 0
          fi

          old_rt="${{ secrets.HYTALE_REFRESH_TOKEN }}"
          if [[ "$new_rt" == "$old_rt" ]]; then
            echo "Refresh token unchanged, no update needed"
            exit 0
          fi

          # IMPORTANT: gh reads from stdin if --body is omitted
          printf '%s' "$new_rt" | gh secret set HYTALE_REFRESH_TOKEN -r "$GITHUB_REPOSITORY"

          echo "✓ Updated HYTALE_REFRESH_TOKEN (token rotated by downloader)"

      - name: Get current release version
        id: current
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          version="$(gh release list --limit 1 --json tagName --jq '.[0].tagName // ""' | sed 's/^v//')"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Determine if build is needed
        id: should_build
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event.inputs.force_build }}" == "true" ]]; then
            echo "build=true" >> "$GITHUB_OUTPUT"
          elif [[ "${{ steps.current.outputs.version }}" == "${{ steps.upstream.outputs.version }}" ]]; then
            echo "build=false" >> "$GITHUB_OUTPUT"
          else
            echo "build=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Download server files
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p output
          cd output
          
          # Copy credentials to output directory since we're changing directories
          cp ../.hytale-downloader-credentials.json .hytale-downloader-credentials.json

          timeout 15m stdbuf -oL -eL \
            ../hytale-downloader-linux-amd64 \
            2>&1 | tee downloader-run.log

          # Copy updated credentials back to parent directory for persistence step
          cp .hytale-downloader-credentials.json ../.hytale-downloader-credentials.json

          cd ..

      # Add another token persistence step after download in case it rotated again
      - name: Persist rotated refresh token (after download)
        if: always() && steps.should_build.outputs.build == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_SECRETS_TOKEN }}
        run: |
          set -euo pipefail

          cred=".hytale-downloader-credentials.json"
          if [[ ! -f "$cred" ]]; then
            echo "::warning::No credentials file to persist"
            exit 0
          fi

          new_rt="$(jq -r '.refresh_token // ""' "$cred")"
          if [[ -z "$new_rt" ]]; then
            echo "::warning::Empty refresh token in credentials file"
            exit 0
          fi
          
          if [[ "$new_rt" != ory_rt_* ]]; then
            echo "::warning::Refresh token does not match expected format (ory_rt_*)"
            exit 0
          fi

          old_rt="${{ secrets.HYTALE_REFRESH_TOKEN }}"
          if [[ "$new_rt" == "$old_rt" ]]; then
            echo "Refresh token unchanged, no update needed"
            exit 0
          fi

          printf '%s' "$new_rt" | gh secret set HYTALE_REFRESH_TOKEN -r "$GITHUB_REPOSITORY"

          echo "✓ Updated HYTALE_REFRESH_TOKEN after download (token rotated)"

      - name: Extract and prepare server files
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p stage package

          latest_zip="$(ls -t output/*.zip 2>/dev/null | head -n 1 || true)"
          if [[ -z "$latest_zip" ]]; then
            echo "::error::No ZIP found in output/. Listing output directory:"
            ls -la output || true
            echo "::error::Downloader may have succeeded but did not produce a ZIP. See output/downloader-run.log"
            exit 1
          fi

          unzip -q "$latest_zip" -d stage

          require_one() {
            local pattern="$1"
            local desc="$2"
            local found
            found="$(find stage -name "$pattern" -type f | head -n 1 || true)"
            if [[ -z "$found" ]]; then
              echo "::error::Missing required artifact: ${desc} (pattern: ${pattern})"
              echo "Stage contents:"
              find stage -maxdepth 4 -type f | sed -e 's/^/  /' | head -n 200
              exit 1
            fi
            echo "$found"
          }

          assets_zip="$(require_one 'Assets.zip' 'Assets.zip')"
          server_jar="$(require_one 'HytaleServer.jar' 'HytaleServer.jar')"
          server_aot="$(require_one 'HytaleServer.aot' 'HytaleServer.aot')"

          cp "$assets_zip" package/Assets.zip
          cp "$server_jar" package/HytaleServer.jar
          cp "$server_aot" package/HytaleServer.aot

          if [[ ! -f server/Dockerfile ]]; then
            echo "::error::Missing server/Dockerfile in repo"
            exit 1
          fi
          cp server/Dockerfile package/Dockerfile

          rm -rf stage output

      - name: Generate tags
        if: steps.should_build.outputs.build == 'true'
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          version="${{ steps.upstream.outputs.version }}"
          timestamp="$(date -u +%Y%m%d-%H%M%S)"
          echo "version_tag=v${version}" >> "$GITHUB_OUTPUT"
          echo "timestamp_tag=build-${timestamp}" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        if: steps.should_build.outputs.build == 'true'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: steps.should_build.outputs.build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.should_build.outputs.build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push multi-arch image
        if: steps.should_build.outputs.build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: package
          file: package/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ github.repository_owner }}/hytale-server:latest
            ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.version_tag }}
            ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.timestamp_tag }}

      - name: Create release
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          notes_file="$(mktemp)"
          {
            printf '%s\n' \
              "**Version:** ${{ steps.upstream.outputs.version }}" \
              "**Built:** ${{ steps.tags.outputs.timestamp_tag }}" \
              "" \
              "### Docker Image" \
              "```" \
              "docker pull ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.version_tag }}" \
              "```" \
              "" \
              "### Tags" \
              "- \`latest\`" \
              "- \`${{ steps.tags.outputs.version_tag }}\`" \
              "- \`${{ steps.tags.outputs.timestamp_tag }}\`"
          } > "${notes_file}"

          set +e
          gh release create "${{ steps.tags.outputs.version_tag }}" \
            --title "Hytale Server ${{ steps.upstream.outputs.version }}" \
            --notes-file "${notes_file}" 2> gh-release.err
          rc=$?
          set -e

          if [[ $rc -ne 0 ]]; then
            echo "::error::Failed to create release (exit code $rc). gh output:"
            cat gh-release.err
            exit $rc
          fi
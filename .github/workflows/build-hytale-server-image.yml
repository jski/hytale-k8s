name: Build Hytale Server Image

on:
  push:
    branches:
      - master
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      force_build:
        description: "Force a rebuild even if upstream version is unchanged"
        type: boolean
        default: false

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      packages: write

    env:
      HOME: /home/runner
      XDG_CONFIG_HOME: /home/runner/.config

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Free disk space
        shell: bash
        run: |
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/lib/android || true
          df -h

      - name: Download Hytale downloader tool
        shell: bash
        run: |
          curl -fsSL "https://downloader.hytale.com/hytale-downloader.zip" -o hytale-downloader.zip
          unzip -q hytale-downloader.zip
          chmod +x hytale-downloader-linux-amd64

      - name: Setup OAuth credentials (refresh token)
        shell: bash
        env:
          HYTALE_REFRESH_TOKEN: ${{ secrets.HYTALE_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          if [[ -z "${HYTALE_REFRESH_TOKEN:-}" ]]; then
            echo "::error::Missing required secret HYTALE_REFRESH_TOKEN"
            exit 1
          fi

          # Create a minimal credentials file using ONLY the refresh token.
          # (Access tokens are short-lived and should not be stored in GitHub Secrets.)
          cred_json="$(mktemp)"
          cat > "${cred_json}" <<EOF
          {"refresh_token":"${HYTALE_REFRESH_TOKEN}"}
          EOF
          chmod 600 "${cred_json}"

          echo "Using HOME=${HOME}"
          echo "Using XDG_CONFIG_HOME=${XDG_CONFIG_HOME}"

          # Place the credentials in the most likely locations the downloader will check.
          # 1) Home-based file
          cp "${cred_json}" "${HOME}/.hytale-downloader-credentials.json"
          chmod 600 "${HOME}/.hytale-downloader-credentials.json"

          # 2) XDG config path
          mkdir -p "${XDG_CONFIG_HOME}/hytale-downloader"
          cp "${cred_json}" "${XDG_CONFIG_HOME}/hytale-downloader/credentials.json"
          chmod 600 "${XDG_CONFIG_HOME}/hytale-downloader/credentials.json"

          # Also keep a copy in workspace so later steps that cd can reuse it.
          cp "${cred_json}" "${GITHUB_WORKSPACE}/.hytale-downloader-credentials.json"
          mkdir -p "${GITHUB_WORKSPACE}/.config/hytale-downloader"
          cp "${cred_json}" "${GITHUB_WORKSPACE}/.config/hytale-downloader/credentials.json"

          # Minimal sanity output (no secrets)
          python3 - <<'PY'
          import json, os
          paths = [
              os.path.expanduser("~/.hytale-downloader-credentials.json"),
              os.path.expanduser("~/.config/hytale-downloader/credentials.json"),
          ]
          for p in paths:
              try:
                  d = json.load(open(p))
                  rt = d.get("refresh_token","")
                  print(f"Credentials OK at {p} (refresh_token length={len(rt)})")
              except Exception as e:
                  print(f"Credentials NOT readable at {p}: {e}")
          PY

      - name: Get upstream version
        id: upstream
        shell: bash
        run: |
          set -euo pipefail
          echo "Running downloader to get version..."
          # This call requires auth because it fetches the manifest.
          version="$(./hytale-downloader-linux-amd64 -print-version 2>&1 | tail -n 1 | tr -d '\r\n ')"
          echo "Captured version: ${version}"
          echo "version=${version}" >> "$GITHUB_OUTPUT"

      - name: Get current release version
        id: current
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          version="$(gh release list --limit 1 --json tagName --jq '.[0].tagName // ""' | sed 's/^v//')"
          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "Current version: ${version:-none}"

      - name: Determine if build is needed
        id: should_build
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${{ github.event.inputs.force_build }}" == "true" ]]; then
            echo "build=true" >> "$GITHUB_OUTPUT"
            echo "Build forced via workflow_dispatch"
          elif [[ "${{ steps.current.outputs.version }}" == "${{ steps.upstream.outputs.version }}" ]]; then
            echo "build=false" >> "$GITHUB_OUTPUT"
            echo "Version unchanged (${{ steps.upstream.outputs.version }}), skipping build"
          else
            echo "build=true" >> "$GITHUB_OUTPUT"
            echo "Version changed: ${{ steps.current.outputs.version || 'none' }} -> ${{ steps.upstream.outputs.version }}"
          fi

      - name: Download server files
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          set -euo pipefail

          echo "Using HOME=${HOME}"
          export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

          mkdir -p output
          cd output

          # Ensure creds are present in *this* working directory too (some tools look relative).
          cp "${GITHUB_WORKSPACE}/.hytale-downloader-credentials.json" ./ || true
          mkdir -p .config/hytale-downloader
          cp "${GITHUB_WORKSPACE}/.config/hytale-downloader/credentials.json" .config/hytale-downloader/credentials.json || true

          # Run downloader (downloads server ZIP into ./output)
          ../hytale-downloader-linux-amd64

          cd ..

      - name: Extract and prepare server files
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p stage package
          latest_zip="$(ls -t output/*.zip | head -n 1)"
          unzip -q "$latest_zip" -d stage

          cp "$(find stage -name 'Assets.zip' -type f)" package/Assets.zip
          cp "$(find stage -name 'HytaleServer.jar' -type f)" package/HytaleServer.jar
          cp "$(find stage -name 'HytaleServer.aot' -type f)" package/HytaleServer.aot
          cp server/Dockerfile package/Dockerfile

          rm -rf stage output

      - name: Generate tags
        if: steps.should_build.outputs.build == 'true'
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          version="${{ steps.upstream.outputs.version }}"
          timestamp="$(date -u +%Y%m%d-%H%M%S)"
          echo "version_tag=v${version}" >> "$GITHUB_OUTPUT"
          echo "timestamp_tag=build-${timestamp}" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        if: steps.should_build.outputs.build == 'true'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: steps.should_build.outputs.build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.should_build.outputs.build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push multi-arch image
        if: steps.should_build.outputs.build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: package
          file: package/Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ghcr.io/${{ github.repository_owner }}/hytale-server:latest
            ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.version_tag }}
            ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.timestamp_tag }}

      - name: Create release
        if: steps.should_build.outputs.build == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          notes_file="$(mktemp)"
          {
            printf '%s\n' \
              "**Version:** ${{ steps.upstream.outputs.version }}" \
              "**Built:** ${{ steps.tags.outputs.timestamp_tag }}" \
              "" \
              "### Docker Image" \
              "```" \
              "docker pull ghcr.io/${{ github.repository_owner }}/hytale-server:${{ steps.tags.outputs.version_tag }}" \
              "```" \
              "" \
              "### Tags" \
              "- \`latest\`" \
              "- \`${{ steps.tags.outputs.version_tag }}\`" \
              "- \`${{ steps.tags.outputs.timestamp_tag }}\`"
          } > "${notes_file}"

          gh release create "${{ steps.tags.outputs.version_tag }}" \
            --title "Hytale Server ${{ steps.upstream.outputs.version }}" \
            --notes-file "${notes_file}"
